#!/bin/bash
# 构建运行脚本

set -e

PROJECT_ROOT="$(cd "$(dirname "$0")" && pwd)"
BUILD_DIR="$PROJECT_ROOT/build"

# 默认配置
ACTION="run"
CLEAN=false
FULL_CLEAN=false
REBUILD=false
FRESH=false
USE_ISO=false
DEBUG=false
NO_RUN=false
MODULES=""
CMAKE_OPTS=""
QEMU_MEMORY="4096M"
QEMU_CPUS="2"
QEMU_HDA=""
QEMU_EXTRA=""

# 帮助信息
show_help() {
    cat << EOF
Xnix 构建运行脚本

用法: ./run [选项]

基本操作:
  -h, --help              显示此帮助信息
  -c, --compile           只编译不运行
  -r, --run               编译并运行（默认，增量编译）
  -f, --fresh             清理重新构建并运行（清理 + 编译 + 运行）
  -i, --iso               使用 ISO 模式运行
  -d, --debug             调试模式（等待 GDB 连接 :1234）

清理选项:
  --clean                 只清理编译产物（保留 CMake 缓存）
  --clean-all             完全清理 build 目录
  --rebuild               完全重建（清理 build + 重新配置，不运行）

模块控制:
  -m, --modules <list>    指定载入模块（逗号分隔，默认全部）
                          例: -m init,seriald
                          可用: init, seriald, hello, crashme, user_thread_test

QEMU 配置:
  --mem <size>            内存大小（默认: 128M）
  --smp <n>               CPU 核心数（默认: 1）
  --hda <file>            硬盘镜像文件（FAT 格式）
  --qemu <args>           额外 QEMU 参数

CMake 配置:
  -D<var>=<value>         传递给 CMake 的配置选项
                          例: -DCFG_MAX_CPUS=8 -DENABLE_SMP=ON

示例:
  ./run                                    # 增量编译运行
  ./run -f                                 # 干净构建运行
  ./run -i                                 # 使用 ISO 运行
  ./run -d                                 # 调试模式
  ./run -c                                 # 只编译
  ./run --clean                            # 只清理不编译
  ./run --rebuild                          # 完全重建（包括重新配置）
  ./run -f -i                              # 干净构建 + ISO 运行
  ./run -f --mem 256M --smp 2              # 干净构建 + 自定义配置
  ./run -DCFG_MAX_CPUS=4 -DENABLE_SMP=ON   # 修改编译选项
  ./run --qemu "-serial file:serial.log"   # 额外 QEMU 参数

EOF
}

# 解析参数
while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            show_help
            exit 0
            ;;
        -c|--compile)
            ACTION="compile"
            NO_RUN=true
            shift
            ;;
        -r|--run)
            ACTION="run"
            shift
            ;;
        -f|--fresh)
            FRESH=true
            shift
            ;;
        -i|--iso)
            USE_ISO=true
            shift
            ;;
        -d|--debug)
            DEBUG=true
            NO_RUN=false
            shift
            ;;
        --clean)
            CLEAN=true
            NO_RUN=true
            shift
            ;;
        --clean-all)
            FULL_CLEAN=true
            NO_RUN=true
            shift
            ;;
        --rebuild)
            REBUILD=true
            NO_RUN=true
            shift
            ;;
        -m|--modules)
            MODULES="$2"
            shift 2
            ;;
        --mem)
            QEMU_MEMORY="$2"
            shift 2
            ;;
        --smp)
            QEMU_CPUS="$2"
            shift 2
            ;;
        --hda)
            QEMU_HDA="$2"
            shift 2
            ;;
        --qemu)
            QEMU_EXTRA="$2"
            shift 2
            ;;
        -D*)
            CMAKE_OPTS="$CMAKE_OPTS $1"
            shift
            ;;
        *)
            echo "未知选项: $1"
            echo "使用 --help 查看帮助"
            exit 1
            ;;
    esac
done

# 获取 CPU 核心数
JOBS=$(nproc 2>/dev/null || echo 4)

# 清理操作
if $FULL_CLEAN; then
    echo "清理 build 目录..."
    rm -rf "$BUILD_DIR"
    echo "已删除 build 目录"
    exit 0
fi

if $CLEAN; then
    echo "清理编译产物..."
    if [ -d "$BUILD_DIR" ]; then
        cd "$BUILD_DIR"
        make clean 2>/dev/null || cmake --build . --target clean || true
        echo "已清理（使用 --clean-all 完全删除 build 目录）"
    else
        echo "build 目录不存在，无需清理"
    fi
    exit 0
fi

# 重建操作
if $REBUILD; then
    echo "完全重建..."
    rm -rf "$BUILD_DIR"
fi

# 干净构建（清理编译产物但保留 CMake 缓存）
if $FRESH; then
    echo "清理构建..."
    if [ -d "$BUILD_DIR" ]; then
        cd "$BUILD_DIR"
        make clean 2>/dev/null || cmake --build . --target clean || true
        echo "已清理"
    fi
fi

# 初始化构建目录
if [ ! -d "$BUILD_DIR" ]; then
    echo "初始化构建目录..."
    mkdir -p "$BUILD_DIR"
    cd "$BUILD_DIR"
    cmake $CMAKE_OPTS ..
elif [ -n "$CMAKE_OPTS" ]; then
    echo "重新配置 CMake..."
    cd "$BUILD_DIR"
    cmake $CMAKE_OPTS ..
else
    cd "$BUILD_DIR"
fi

# 编译
if $USE_ISO || [ "$ACTION" = "compile" ]; then
    echo "编译（$JOBS 个核心）..."
    if $USE_ISO; then
        cmake --build . -j$JOBS --target iso
    else
        cmake --build . -j$JOBS
    fi
fi

if $NO_RUN; then
    echo "编译完成"
    exit 0
fi

# 快速编译必要模块
if ! $USE_ISO; then
    echo "快速编译核心模块（-j$JOBS）..."
    cmake --build . -j$JOBS --target xnix.elf --target init.elf --target seriald.elf 2>&1 | grep -v "Built target" || true
fi

# 构建 QEMU 命令
QEMU_CMD="qemu-system-i386"
QEMU_ARGS="-serial stdio -no-reboot"

# 内存和 CPU
QEMU_ARGS="$QEMU_ARGS -m $QEMU_MEMORY -smp $QEMU_CPUS"

# 硬盘
if [ -n "$QEMU_HDA" ]; then
    if [ ! -f "$QEMU_HDA" ]; then
        echo "错误: 硬盘镜像不存在: $QEMU_HDA"
        exit 1
    fi
    QEMU_ARGS="$QEMU_ARGS -drive file=$QEMU_HDA,format=raw,if=ide"
fi

# 调试模式
if $DEBUG; then
    QEMU_ARGS="$QEMU_ARGS -s -S"
    echo ""
    echo "启动 QEMU 调试模式..."
    echo "    在另一个终端运行: gdb build/xnix.elf -ex 'target remote :1234'"
    echo ""
fi

# 额外参数
if [ -n "$QEMU_EXTRA" ]; then
    QEMU_ARGS="$QEMU_ARGS $QEMU_EXTRA"
fi

# 运行
if $USE_ISO; then
    echo "从 ISO 启动 Xnix..."
    $QEMU_CMD -cdrom xnix.iso -boot d $QEMU_ARGS
else
    if ! $DEBUG; then
        echo "启动 Xnix..."
    fi
    $QEMU_CMD -kernel xnix.elf $QEMU_ARGS
fi
