cmake_minimum_required(VERSION 3.20)
project(Xnix C ASM)
set(CMAKE_C_STANDARD 11)

# ============================================
# 架构设置
# ============================================
set(ARCH "x86")   # 可切换为 arm/riscv
set(ARCH_DIR "${CMAKE_SOURCE_DIR}/kernel/arch/${ARCH}")

# 生成架构包装头文件: kernel/arch/x86/include/*.h -> kernel/arch/*.h
set(ARCH_WRAPPER_DIR "${CMAKE_SOURCE_DIR}/kernel/arch")
file(GLOB ARCH_HEADERS "${ARCH_DIR}/include/*.h")
foreach(HEADER ${ARCH_HEADERS})
    get_filename_component(HEADER_NAME ${HEADER} NAME)
    file(WRITE "${ARCH_WRAPPER_DIR}/${HEADER_NAME}"
        "// Auto-generated by CMake - DO NOT EDIT\n#pragma once\n\n#include \"${ARCH}/include/${HEADER_NAME}\"\n")
endforeach()

# ============================================
# 编译选项
# ============================================
set(CMAKE_C_FLAGS "-m32 -ffreestanding -fno-stack-protector -fno-pie -nostdlib -nostartfiles -Wall -Wextra")
set(CMAKE_C_FLAGS_DEBUG "-g -O0")
set(CMAKE_C_FLAGS_RELEASE "-O2")
set(CMAKE_ASM_FLAGS "-m32 -g")
set(CMAKE_EXE_LINKER_FLAGS "-m32 -T${ARCH_DIR}/boot/kernel.ld -nostdlib -no-pie")

# ============================================
# 源文件收集
# ============================================
file(GLOB_RECURSE KERNEL_C   "${CMAKE_SOURCE_DIR}/kernel/main/*.c")
file(GLOB_RECURSE ARCH_C     "${ARCH_DIR}/*.c")
file(GLOB_RECURSE ARCH_ASM   "${ARCH_DIR}/*.s")
set(KERNEL_SOURCES ${KERNEL_C} ${ARCH_C} ${ARCH_ASM})

# ============================================
# 创建 ELF 内核目标
# ============================================
add_executable(xnix.elf ${KERNEL_SOURCES})

# ============================================
# 头文件搜索路径 & 索引（CLion）
# ============================================
target_include_directories(xnix.elf PRIVATE
        ${CMAKE_SOURCE_DIR}/kernel
        ${CMAKE_SOURCE_DIR}/kernel/arch
        ${ARCH_DIR}/include
)

file(GLOB_RECURSE KERNEL_HEADERS
        "${CMAKE_SOURCE_DIR}/kernel/*.h"
        "${ARCH_DIR}/*.h"
)
target_sources(xnix.elf PRIVATE ${KERNEL_HEADERS})

# ============================================
# 创建可引导 ISO
# ============================================
set(ISO_DIR "${CMAKE_BINARY_DIR}/isodir")
add_custom_command(
        OUTPUT ${CMAKE_BINARY_DIR}/xnix.iso
        COMMAND ${CMAKE_COMMAND} -E make_directory ${ISO_DIR}/boot/grub
        COMMAND ${CMAKE_COMMAND} -E copy $<TARGET_FILE:xnix.elf> ${ISO_DIR}/boot/xnix.elf
        COMMAND ${CMAKE_COMMAND} -E echo "set timeout=0" > ${ISO_DIR}/boot/grub/grub.cfg
        COMMAND ${CMAKE_COMMAND} -E echo "set default=0" >> ${ISO_DIR}/boot/grub/grub.cfg
        COMMAND ${CMAKE_COMMAND} -E echo "menuentry \\\"Xnix\\\" { multiboot /boot/xnix.elf }" >> ${ISO_DIR}/boot/grub/grub.cfg
        COMMAND grub-mkrescue -o ${CMAKE_BINARY_DIR}/xnix.iso ${ISO_DIR} 2>/dev/null || true
        DEPENDS xnix.elf
        COMMENT "创建可引导 ISO..."
)
add_custom_target(iso DEPENDS ${CMAKE_BINARY_DIR}/xnix.iso)

# ============================================
# QEMU 运行/调试
# ============================================
add_custom_target(run
        COMMAND qemu-system-i386 -cdrom ${CMAKE_BINARY_DIR}/xnix.iso
        DEPENDS iso
        COMMENT "在 QEMU 中运行 Xnix..."
        VERBATIM
)

add_custom_target(debug
        COMMAND qemu-system-i386 -kernel ${CMAKE_BINARY_DIR}/xnix.elf -s -S
        DEPENDS xnix.elf
        COMMENT "在 QEMU 调试模式下运行 Xnix (等待 GDB 连接端口1234)..."
        VERBATIM
)
